> ①、引用计数算法：通过对象被引用的次数确定对象是否被使用，缺点是无法解决循环引用的问题。
> ②、复制算法：分为from块和to块，开始在from块，回收时将from块存活的对象复制到to块，将from块清空，to块变from块，from块变to块，缺点是内存使用率较低。
> ③、标记清除算法：分为标记对象和标记不在使用的对象两个阶段，缺点是会产生内存碎片。
> ④、标记整理算法：与标记清除算法相同，不过在清楚后会进行内存整理。
> ⑤、分代回收算法：当前的商业虚拟机的垃圾收集都是采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把堆划分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就采用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。



Minor GC 年轻代的回收

Major GC 年老代的回收





### CMS收集器

　　Concurrent Mark Sweep，以获取最短回收停顿时间为目标的收集器，基于并发“标记清理”实现。JDK1.7之前的默认垃圾回收算法，并发收集，停顿小。

优点:

　　并发，低停顿

缺点：

　　1、对CPU非常敏感：在并发阶段虽然不会导致用户线程停顿，但是会因为占用了一部分线程使应用程序变慢

　　2、无法处理浮动垃圾：在最后一步并发清理过程中，用户县城执行也会产生垃圾，但是这部分垃圾是在标记之后，所以只有等到下一次gc的时候清理掉，这部分垃圾叫浮动垃圾

　　3、CMS使用“标记-清理”法会产生大量的空间碎片，当碎片过多，将会给大对象空间的分配带来很大的麻烦，往往会出现老年代还有很大的空间但无法找到足够大的连续空间来分配当前对象，不得不提前触发一次FullGC，为了解决这个问题CMS提供了一个开关参数，用于在CMS顶不住，要进行FullGC时开启内存碎片的合并整理过程，但是内存整理的过程是无法并发的，空间碎片没有了但是停顿时间变长了

过程：

　　1、初始标记：独占PUC，仅标记GCroots能直接关联的对象

　　　**补充点：GCroots能直接关联的4种对象**

　　　　**①、虚拟机栈中引用的对象；②、方法区中类静态属性引用的对象；③、方法区中常量引用的对象；④、本地方法栈JNI（native方法）引用的对象**

 

　　2、并发标记：可以和用户线程并行执行，标记所有可达对象

　　3、重新标记：独占CPU(STW)，对并发标记阶段用户线程运行产生的垃圾对象进行标记修正

　　4、并发清理：可以和用户线程并行执行，清理垃圾

[![6gYb0U.png](https://s3.ax1x.com/2021/03/18/6gYb0U.png)](https://imgtu.com/i/6gYb0U)



CMS 出现FullGC的原因：

　　1、年轻带晋升到老年带没有足够的连续空间，很有可能是内存碎片导致的

　　2、在并发过程中JVM觉得在并发过程结束之前堆就会满，需要提前触发FullGC



### G1收集器

　　Garbage First，是一款面向服务端应用的垃圾收集器。G1算法JDK1.9之后默认回收算法，特点是保持高回收率的同时，减少停顿。

特点：

　　1、并行于并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。

　　2、分代收集：分代概念在G1中依然得以保留。虽然G1可以不需要其它收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。也就是说G1可以自己管理新生代和老年代了。

　　3、空间整合：由于G1使用了独立区域（Region）概念，G1从整体来看是基于“标记-整理”算法实现收集，从局部（两个Region）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片。

　　4、可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用这明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

 

如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：

1、初始标记（Initial Making）

2、并发标记（Concurrent Marking）

3、最终标记（Final Marking）

4、筛选回收（Live Data Counting and Evacuation）

[![6gtmct.png](https://s3.ax1x.com/2021/03/18/6gtmct.png)](https://imgtu.com/i/6gtmct)



- g1和cms区别
- 你说g1可以计算回收的收益，那cms为什么不可以呢，据我所知cms也可以
- g1为什么可以做到低延迟？
- g1如何计算回收的收益来估计延迟呢？



